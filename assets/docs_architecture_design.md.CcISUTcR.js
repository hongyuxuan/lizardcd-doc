import{_ as e,c as a,o as i,a3 as s}from"./chunks/framework.CVQlUOPj.js";const u=JSON.parse('{"title":"部署架构","description":"","frontmatter":{},"headers":[],"relativePath":"docs/architecture/design.md","filePath":"docs/architecture/design.md","lastUpdated":1720844699000}'),t={name:"docs/architecture/design.md"},c=s(`<h1 id="部署架构" tabindex="-1">部署架构 <a class="header-anchor" href="#部署架构" aria-label="Permalink to &quot;部署架构&quot;">​</a></h1><p>本章节介绍 Lizardcd 的各个组件以及架构设计。</p><h2 id="组件介绍" tabindex="-1">组件介绍 <a class="header-anchor" href="#组件介绍" aria-label="Permalink to &quot;组件介绍&quot;">​</a></h2><p>Lizardcd 由以下4个组件构成：</p><ul><li>lizardcd-agent：agent 使用 Kubernetes <code>client-go</code> SDK 与 APIServer 通信。agent 启动时监听在 gRPC 端口，同时将自己注册到<code>服务注册中心</code>。Lizardcd 目前支持三种注册中心： <code>etcd</code>、<code>consul</code> 或 <code>nacas</code>（使用 Helm 部署时，可选择是否同时部署 etcd/consul/nacos，或者使用一个外部的 etcd/consul/nacos）。agent 的启动配置文件需要指定自己注册时使用的 <code>Key</code>，<code>Key</code> 的取值必须满足一定格式，详见 <a href="/lizardcd-doc/docs/deploy/configure/agent.html">agent 配置说明</a>。agent 是无状态的，可以任意横向扩展。</li><li>lizardcd-server：server 启动后将持续监听<code>服务注册中心</code>，并根据 agent 注册的地址与 agent 的 gRPC 端口建立长连接，同时将该条连接保存于 server 自身的内存中。server 通过 Restful API 与 lizardcd-ui 或 lizardcd-cli 通信，接收图形化或客户端指令，对于部分指令通过 gRPC 下发给 agent 执行。</li><li>lizardcd-ui：Lizardcd 的图形化界面，主要的平台入口。</li><li>lizardcd-cli：Lizardcd 的客户端工具，目前支持 Windows 和 Linux。注意 cli 仅支持部分 Lizardcd 功能，详见 <a href="/lizardcd-doc/docs/cli/cli.html">客户端用法</a></li></ul><h2 id="架构设计" tabindex="-1">架构设计 <a class="header-anchor" href="#架构设计" aria-label="Permalink to &quot;架构设计&quot;">​</a></h2><p>Lizardcd 的后端服务（包括 server 和 agent）和客户端（cli）全部由 Golang 编写，后端基于 <a href="https://go-zero.dev/" target="_blank" rel="noreferrer">go-zero</a> 框架，客户端基于 <a href="https://github.com/spf13/cobra" target="_blank" rel="noreferrer">cobra</a> 框架。前端 ui 由 Javascript 和 Vue3 编写，基于 <a href="https://element-plus.org/zh-CN/" target="_blank" rel="noreferrer">element-plus</a> 框架。</p><h3 id="总体架构" tabindex="-1">总体架构 <a class="header-anchor" href="#总体架构" aria-label="Permalink to &quot;总体架构&quot;">​</a></h3><p>Lizardcd 的总体架构如下：</p><p><img src="https://project-1255547500.cos.ap-beijing.myqcloud.com/lizardcd/lizardcd%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="" data-fancybox="gallery"></p><h3 id="agent设计" tabindex="-1">agent设计 <a class="header-anchor" href="#agent设计" aria-label="Permalink to &quot;agent设计&quot;">​</a></h3><p>Lizardcd 的 agent 支持以 <code>deployment</code> 形式部署于 Kubernetes 中，此时 agent 通过 <code>serviceaccount</code> 与 APIServer 通讯，无需 <code>kubeconfig</code>，也不用知道 APIServer 的地址和证书。agent 所具有的权限取决于 <code>serviceaccount</code> 的 RBAC 权限。详见 <a href="/lizardcd-doc/docs/deploy/configure/rbac.html">RBAC权限设置</a>。</p><p>agent 还支持以 <code>二进制</code> 形式运行于 Windows 或 Linux 系统上，此时 agent 需要通过 <code>kubeconfig</code> 与 APIServer 通信。agent 所具有的权限取决于 <code>kubeconfig</code> 中设置的 user 的 RBAC权限。</p><p>每一个 agent 的纳管范围（通常指 namespace）取决于其所使用的 <code>serviceaccount</code> 或 <code>kubeconfig</code> 的权限范围，假设其所使用的 <code>kubeconfig</code> 对集群所有 namespace 都有权限，那么 agent 的纳管范围即该集群的所有 namespace。而通常一个 agent 最多纳管一个集群（<code>kubeconfig</code> 中的 <code>current-context</code> 指向的 APIServer）。</p><h3 id="server设计" tabindex="-1">server设计 <a class="header-anchor" href="#server设计" aria-label="Permalink to &quot;server设计&quot;">​</a></h3><p>server 的纳管范围是所有已连通的 agent 纳管范围的集合，而我们通常说一个 Lizardcd 能纳管多少个集群，实际上是说所有 agent 纳管了多少集群。</p><p>server 设计为有状态的，与 server 通信需要先通过 <code>login</code> 接口获取一个 <code>JWT Token</code>，默认的 <code>JWT Token</code> 过期时间是 1 天。</p><p>server 与 agent 之间通过 gRPC 协议通信，符合大多数云原生工具的组件间通信习惯（如Prometheus）。server 会将与每一个 agent 建立的 gRPC 连接保存在内存中，其结构如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RpcAgent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Client        </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lizardagent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">LizardAgent</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	ServiceSource </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Cli           </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zrpc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Client</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	Count         </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>其中 <code>lizardagent.LizardAgent</code> 即 agent 的 <code>gRPC client</code> 接口类型。<code>ServiceSource</code> 标识该 agent 注册于哪一种注册中心（取值：etcd/consul/nacos）。<code>zrpc.Client</code> 是 server 端的 Conn 对象。<code>Count</code> 标识当前与 server 建立连接的 agent 有多少个实例（agent 可以横向扩容成多实例），每当一个 agent 的新实例添加到<code>服务注册中心</code>时，server 会捕捉到该 agent 注册的 服务名 Key，如果 Key 已存在，则 Count ++。</p><p>当 server 收到上游指令时，其快速从内存中取出一条对应的连接，即 <code>RpcAgent</code> 对象，并通过对象中的 <code>Client</code> 对 agent 发起 gRPC 调用。这种设计的一个弊端是，当 agent 数量不断增大时，server 的内存会持续增长，因此 Lizardcd 也许并不适合海量规模的集群管理，但对于中小规模的集群，其具有相当可观的性能表现。</p>`,21),n=[c];function r(d,o,l,p,h,g){return i(),a("div",null,n)}const E=e(t,[["render",r]]);export{u as __pageData,E as default};
